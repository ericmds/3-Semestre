# Alocação Dinâmica x Alocação Estática

### Alocação Dinâmica
* C e C++
  * malloc / free
* Java e C#
  * new
  * dispose ou garbage collector
 
tpedef Struct nó {
  int dado;
  Struct nó *prox;
} Celula;

* Observações 
  * i != NULL é a mesma coisa que somente i
  * " -> " em C sempre vai se referir ao endereço de memória

## Lista.cpp
```cpp
#include <iostream>

using namespace std;

#include "lista.h"

int main() {
    // LISTA É DO TIPO PONTEIRO DE CÉLULA
    Celula *lista = NULL;

    lista = inserir(7, lista);
    lista = inserir(10, lista);
    lista = inserir(5, lista);

    cout << "Lista contem " << contarLista(lista) << " elementos\n";
    exibir(lista);

    int numero;
    cout << "Digite numero para pesquisa: ";
    cin >> numero;

    cout << numero << " esta na lista? " << estaNaLista(numero, lista) << endl;
    
    // Contar ocorrências de um número

    // Verificar se a lista está oyu não ordenada

    // Calcular a média dos elementos da lista

    // Alterar o inserir para que controle duplicados - Ou seja, proiba cadastro de replicados

    return 1;
}


// dir
//  g++ .\lista.cpp -o roda
//  .\roda.exe
```
## Lista.h
```h
#include <cstdlib>

typedef struct no {
    int dado;
    struct no *prox;
} Celula;

// REALIZANDO O ADD EM DE JAVA EM C++
Celula *inserir(int dado, Celula *lista) {
    // Alocar memóra
    Celula *novo = (Celula *)malloc(sizeof(Celula));

    // Depositar valores que vem do parâmetro
    novo->dado = dado;
    novo->prox = NULL;

    // Testar se é o primeiro elemento a ser inserido
    if (!lista)
    { // mesma coisa que if (lista == NULL)
        return novo;
    }

    // Percorrer a estrutura até o final
    Celula *p;
    for (p = lista; p->prox != NULL; p = p->prox)
        ;

    // Encadear e retornar
    p->prox = novo;
    return lista;
}

void exibir(Celula *lista) {
    for (Celula *p = lista; p != NULL; p = p->prox)
    {
        cout << p->dado << "\t";
    }
    cout << endl;
}

int contarLista(Celula *lista) {
    int total = 0;

    for (Celula *p = lista; p != NULL; p = p->prox) {
        total++;
    }
  
    return total;
}

bool estaNaLista (int dado, Celula *lista) {
    for (Celula *p = lista; p != NULL; p = p->prox) {
        if (dado == p->dado) {
            return true; // 1
        }
    }
    return false; // 0 ou não localizado;
}
```
